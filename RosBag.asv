out=RosBag(gate_run_01/)

function out = RosBag(bagFolder)

TOP.odom = "/odom";
TOP.goal = "/steelhead/controls/waypoint_marker/current_goal";
TOP.goal2 = "/steelhead/controls/waypoint_marker/set";
TOP.wrench = "/steelhead/controls/input_forces";

CFG.dt = 0.02;

CFG.settle_band_yaw_deg = 2.0;
CFG.settle_band_ct_m = 0.15;
CFG.settle_hold_s = 1.0;

CFG.force_lat_limit = NaN;
CFG.torque_yaw_limit = NaN;

bag = ros2bagreader(bagFolder);

odomSel = select(bag,"Topic",TOP.odom);
odomMsg = readMessages(odomSel,"DataFormat","struct");
[tO, pO, yawO] = extractOdom(odomMsg);

goalTopic = "";
if any(strcmp(bag.AvailableTopics.Topic, TOP.goal))
    goalTopic = TOP.goal;
elseif any(strcmp(bag.AvailableTopics.Topic, TOP.goal2))
    goalTopic = TOP.goal2;
else
    error("No goal waypoint topic found. Expected %s or %s", TOP.goal, TOP.goal2);
end

goalSel = select(bag,"Topic",goalTopic);
goalMsg = readMessages(goalSel,"DataFormat","struct");
[tG, pG] = extractWaypoint(goalMsg);

wrenchSel = select(bag,"Topic",TOP.wrench);
wrenchMsg = readMessages(wrenchSel,"DataFormat","struct");
[tU, uLat, uYaw] = extractWrench(wrenchMsg);

t0 = max([tO(1), tG(1), tU(1)]);
t1 = min([tO(end), tG(end), tU(end)]);
t = (t0:CFG.dt:t1)';

pO_i = interp1(tO, pO, t, "linear", "extrap");
yawO_i = interp1(tO, yawO, t, "linear", "extrap");

pG_i = interp1(tG, pG, t, "previous", "extrap");

uLat_i = interp1(tU, uLat, t, "linear", "extrap");
uYaw_i = interp1(tU, uYaw, t, "linear", "extrap");

v = pG_i(:,1:2) - pO_i(:,1:2);
vn = vecnorm(v,2,2);
tHat = v ./ max(vn, 1e-9);

dx = pO_i(:,1) - pG_i(:,1);
dy = pO_i(:,2) - pG_i(:,2);

e_ct = dx .* tHat(:,2) - dy .* tHat(:,1);

yawDes = atan2(tHat(:,2), tHat(:,1));
e_yaw = wrapToPi(yawDes - yawO_i);

bandYaw = deg2rad(CFG.settle_band_yaw_deg);
bandCT = CFG.settle_band_ct_m;

ts_yaw = settlingTime(t, e_yaw, bandYaw, CFG.settle_hold_s);
ts_ct  = settlingTime(t, e_ct,  bandCT,  CFG.settle_hold_s);

peak_yaw = max(abs(e_yaw));
peak_ct  = max(abs(e_ct));

eff_yaw = trapz(t, abs(uYaw_i));
eff_lat = trapz(t, abs(uLat_i));

sat_yaw_pct = NaN;
sat_lat_pct = NaN;

if ~isnan(CFG.torque_yaw_limit)
    sat_yaw_pct = 100 * mean(abs(uYaw_i) >= 0.99*CFG.torque_yaw_limit);
end
if ~isnan(CFG.force_lat_limit)
    sat_lat_pct = 100 * mean(abs(uLat_i) >= 0.99*CFG.force_lat_limit);
end

out = struct();
out.t = t;
out.cross_track_m = e_ct;
out.heading_err_rad = e_yaw;
out.u_lat_force = uLat_i;
out.u_yaw_torque = uYaw_i;

out.metrics = table( ...
    ts_yaw, ts_ct, ...
    peak_yaw, peak_ct, ...
    eff_yaw, eff_lat, ...
    sat_yaw_pct, sat_lat_pct, ...
    'VariableNames', { ...
        "settle_yaw_s","settle_ct_s", ...
        "peak_yaw_rad","peak_ct_m", ...
        "eff_yaw_int_abs","eff_lat_int_abs", ...
        "sat_yaw_pct","sat_lat_pct"});

disp(out.metrics);

figure;
plot(t - t(1), e_ct); grid on;
xlabel("t (s)"); ylabel("cross-track error (m)");
title("Cross-track error vs time");

figure;
plot(t - t(1), rad2deg(e_yaw)); grid on;
xlabel("t (s)"); ylabel("heading error (deg)");
title("Heading error vs time");

figure;
plot(t - t(1), uLat_i); grid on;
xlabel("t (s)"); ylabel("lateral force command");
title("Control input: lateral (from Wrench.force.y)");

figure;
plot(t - t(1), uYaw_i); grid on;
xlabel("t (s)"); ylabel("yaw torque command");
title("Control input: yaw (from Wrench.torque.z)");

end

function [t, p, yaw] = extractOdom(msgs)
n = numel(msgs);
t = zeros(n,1);
p = zeros(n,3);
yaw = zeros(n,1);

for k=1:n
    t(k) = stampToSec(msgs{k}.header.stamp);

    pos = msgs{k}.pose.pose.position;
    p(k,1) = double(pos.x);
    p(k,2) = double(pos.y);
    p(k,3) = double(pos.z);

    q = msgs{k}.pose.pose.orientation;
    yaw(k) = quatYaw(double(q.w), double(q.x), double(q.y), double(q.z));
end

yaw = unwrap(yaw);
end

function [t, pG] = extractWaypoint(msgs)
n = numel(msgs);
t = zeros(n,1);
pG = zeros(n,3);

for k=1:n
    if isfield(msgs{k}, "header") && isfield(msgs{k}.header, "stamp")
        t(k) = stampToSec(msgs{k}.header.stamp);
    elseif isfield(msgs{k}, "stamp")
        t(k) = stampToSec(msgs{k}.stamp);
    else
        t(k) = NaN;
    end

    pG(k,:) = waypointPos(msgs{k});
end

if any(isnan(t))
    t = (0:n-1)';
end
end

function p = waypointPos(m)
p = [0 0 0];

if isfield(m, "position")
    if isstruct(m.position)
        p(1) = double(getField(m.position, "x", 0));
        p(2) = double(getField(m.position, "y", 0));
        p(3) = double(getField(m.position, "z", 0));
        return;
    end
end

if isfield(m, "pose") && isfield(m.pose, "position")
    p(1) = double(getField(m.pose.position, "x", 0));
    p(2) = double(getField(m.pose.position, "y", 0));
    p(3) = double(getField(m.pose.position, "z", 0));
    return;
end

p(1) = double(getField(m, "x", 0));
p(2) = double(getField(m, "y", 0));
p(3) = double(getField(m, "z", 0));
end

function [t, uLat, uYaw] = extractWrench(msgs)
n = numel(msgs);
t = zeros(n,1);
uLat = zeros(n,1);
uYaw = zeros(n,1);

for k=1:n
    if isfield(msgs{k}, "header") && isfield(msgs{k}.header, "stamp")
        t(k) = stampToSec(msgs{k}.header.stamp);
    elseif isfield(msgs{k}, "stamp")
        t(k) = stampToSec(msgs{k}.stamp);
    else
        t(k) = NaN;
    end

    f = msgs{k}.force;
    tau = msgs{k}.torque;

    uLat(k) = double(getField(f, "y", 0));
    uYaw(k) = double(getField(tau, "z", 0));
end

if any(isnan(t))
    t = (0:n-1)';
end
end

function ts = stampToSec(stamp)
ts = double(stamp.sec) + 1e-9*double(stamp.nanosec);
end

function y = quatYaw(w, x, yq, z)
sinY = 2*(w*z + x*yq);
cosY = 1 - 2*(yq*yq + z*z);
y = atan2(sinY, cosY);
end

function ts = settlingTime(t, e, band, hold_s)
dt = median(diff(t));
holdN = max(1, round(hold_s / max(dt,1e-9)));
inside = abs(e) <= band;
ts = NaN;

for k=1:(numel(t)-holdN)
    if all(inside(k:k+holdN))
        ts = t(k) - t(1);
        return;
    end
end
end

function v = getField(s, name, defaultVal)
if isfield(s, name)
    v = s.(name);
else
    v = defaultVal;
end
end
